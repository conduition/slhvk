// Work group size
layout(constant_id = 0) const uint WORK_GROUP_SIZE = 64;
layout(local_size_x_id = 0) in;

// Number of SHA256 state words to write to the output buffer.
//   HASH_WORDS = N / 4
#define HASH_WORDS 4

// SLH-DSA parameters
#define FORS_TREE_HEIGHT 12
#define FORS_TREE_COUNT 14
#define WOTS_LOG_W 4
#define WOTS_CHAIN_COUNT1 32
#define WOTS_CHAIN_COUNT2 3
#define XMSS_HEIGHT 9
#define HYPERTREE_LAYERS 7

#define FORS_LEAVES_COUNT (1 << FORS_TREE_HEIGHT)
#define FORS_SIGNATURE_WORDS (HASH_WORDS * FORS_TREE_COUNT * (1 + FORS_TREE_HEIGHT))
#define HYPERTREE_SIGNATURE_START_OFFSET (HASH_WORDS + FORS_SIGNATURE_WORDS)
#define WOTS_CHAIN_COUNT (WOTS_CHAIN_COUNT1 + WOTS_CHAIN_COUNT2)
#define WOTS_CHAIN_LEN (1 << WOTS_LOG_W)
#define XMSS_LEAVES (1 << XMSS_HEIGHT)
#define XMSS_SIGNATURE_WORDS (HASH_WORDS * (WOTS_CHAIN_COUNT + XMSS_HEIGHT))
#define WOTS_CHAINS_PER_LAYER (XMSS_LEAVES * WOTS_CHAIN_COUNT)
#define HYPERTREE_SIGNATURE_WORDS (XMSS_SIGNATURE_WORDS * HYPERTREE_LAYERS)

const uint K[] = {
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};


#define rotr(x, n) bitfieldInsert(x >> n, x, int(32 - n), int(n))

// By the boolean distributive law:
//   (x & y) ^ (x & z) = x & (y ^ z)
//
// Thus:
//   Maj(x, y, z) = (x & y) ^ (x & z) ^ (y & z)
//                = (x & (y ^ z)) ^ (y & z)
//
// This removes one XOR and one AND operation from the Maj function
#define maj(x, y, z) ((x & (y ^ z)) ^ (y & z))
#define ch(e, f, g) ((e & f) ^ ((~e) & g))

#define sum0(x) (rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22))
#define sum1(x) (rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25))

#define sigma0(x) (rotr(x, 7) ^ rotr(x, 18) ^ (x >> 3))
#define sigma1(x) (rotr(x, 17) ^ rotr(x, 19) ^ (x >> 10))

#define SHA256_ROUND(a, b, c, d, e, f, g, h, r, w) {\
  uint t1 = h + sum1(e) + ch(e, f, g) + K[r] + w; \
  uint t2 = sum0(a) + maj(a, b, c); \
  d = d + t1; \
  h = t1 + t2; \
}

#define populate_message_schedule(schedule, t) { \
  schedule[t] = \
    sigma1(schedule[t - 2]) + \
    schedule[t - 7] + \
    sigma0(schedule[t - 15]) + \
    schedule[t - 16]; \
}

#define sha256_rounds_5_thru_64(s, schedule, old_state) { \
  /*            a     b     c     d     e     f     g     h   round   w[round] */ \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  5,   schedule[5]) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  6,   schedule[6]) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  7,   schedule[7]) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  8,   schedule[8]) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  9,   schedule[9]) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  10,  schedule[10]) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  11,  schedule[11]) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  12,  schedule[12]) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  13,  schedule[13]) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  14,  schedule[14]) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  15,  schedule[15]) \
  populate_message_schedule(schedule, 16) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  16,  schedule[16]) \
  populate_message_schedule(schedule, 17) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  17,  schedule[17]) \
  populate_message_schedule(schedule, 18) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  18,  schedule[18]) \
  populate_message_schedule(schedule, 19) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  19,  schedule[19]) \
  populate_message_schedule(schedule, 20) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  20,  schedule[20]) \
  populate_message_schedule(schedule, 21) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  21,  schedule[21]) \
  populate_message_schedule(schedule, 22) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  22,  schedule[22]) \
  populate_message_schedule(schedule, 23) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  23,  schedule[23]) \
  populate_message_schedule(schedule, 24) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  24,  schedule[24]) \
  populate_message_schedule(schedule, 25) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  25,  schedule[25]) \
  populate_message_schedule(schedule, 26) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  26,  schedule[26]) \
  populate_message_schedule(schedule, 27) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  27,  schedule[27]) \
  populate_message_schedule(schedule, 28) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  28,  schedule[28]) \
  populate_message_schedule(schedule, 29) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  29,  schedule[29]) \
  populate_message_schedule(schedule, 30) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  30,  schedule[30]) \
  populate_message_schedule(schedule, 31) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  31,  schedule[31]) \
  populate_message_schedule(schedule, 32) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  32,  schedule[32]) \
  populate_message_schedule(schedule, 33) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  33,  schedule[33]) \
  populate_message_schedule(schedule, 34) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  34,  schedule[34]) \
  populate_message_schedule(schedule, 35) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  35,  schedule[35]) \
  populate_message_schedule(schedule, 36) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  36,  schedule[36]) \
  populate_message_schedule(schedule, 37) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  37,  schedule[37]) \
  populate_message_schedule(schedule, 38) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  38,  schedule[38]) \
  populate_message_schedule(schedule, 39) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  39,  schedule[39]) \
  populate_message_schedule(schedule, 40) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  40,  schedule[40]) \
  populate_message_schedule(schedule, 41) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  41,  schedule[41]) \
  populate_message_schedule(schedule, 42) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  42,  schedule[42]) \
  populate_message_schedule(schedule, 43) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  43,  schedule[43]) \
  populate_message_schedule(schedule, 44) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  44,  schedule[44]) \
  populate_message_schedule(schedule, 45) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  45,  schedule[45]) \
  populate_message_schedule(schedule, 46) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  46,  schedule[46]) \
  populate_message_schedule(schedule, 47) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  47,  schedule[47]) \
  populate_message_schedule(schedule, 48) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  48,  schedule[48]) \
  populate_message_schedule(schedule, 49) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  49,  schedule[49]) \
  populate_message_schedule(schedule, 50) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  50,  schedule[50]) \
  populate_message_schedule(schedule, 51) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  51,  schedule[51]) \
  populate_message_schedule(schedule, 52) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  52,  schedule[52]) \
  populate_message_schedule(schedule, 53) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  53,  schedule[53]) \
  populate_message_schedule(schedule, 54) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  54,  schedule[54]) \
  populate_message_schedule(schedule, 55) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  55,  schedule[55]) \
  populate_message_schedule(schedule, 56) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  56,  schedule[56]) \
  populate_message_schedule(schedule, 57) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  57,  schedule[57]) \
  populate_message_schedule(schedule, 58) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  58,  schedule[58]) \
  populate_message_schedule(schedule, 59) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  59,  schedule[59]) \
  populate_message_schedule(schedule, 60) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  60,  schedule[60]) \
  populate_message_schedule(schedule, 61) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  61,  schedule[61]) \
  populate_message_schedule(schedule, 62) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  62,  schedule[62]) \
  populate_message_schedule(schedule, 63) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  63,  schedule[63]) \
  for (int i = 0; i < 8; i++) { \
    s[i] += old_state[i]; \
  } \
}

#define sha256_rounds_0_thru_5(s, schedule) {\
  /*            a     b     c     d     e     f     g     h   round   w[round] */ \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  0,   schedule[0]) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  1,   schedule[1]) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  2,   schedule[2]) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  3,   schedule[3]) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  4,   schedule[4]) \
}

#define sha256_rounds_all(s, schedule) { \
  const uint old_state[8] = s; \
  sha256_rounds_0_thru_5(s, schedule) \
  sha256_rounds_5_thru_64(s, schedule, old_state) \
}

uint flip_endianness(uint v) {
  return (
    bitfieldExtract(v, 0, 8) << 24 |
    bitfieldExtract(v, 8, 8) << 16 |
    bitfieldExtract(v, 16, 8) << 8 |
    bitfieldExtract(v, 24, 8)
  );
}

struct uint64 {
  uint lo;
  uint hi;
};

uint64 shifted_tree_address(uint64 tree_address, uint xmss_height, uint layer_address) {
  uint tree_shift = xmss_height * layer_address; // never more than 63
  if (tree_shift == 0) {
    return uint64(tree_address.lo, tree_address.hi);
  } else if (tree_shift < 32) {
    return uint64(
      (tree_address.hi << (32 - tree_shift)) | (tree_address.lo >> tree_shift),
      tree_address.hi >> tree_shift
    );
  } else {
    return uint64(
      tree_address.hi >> (tree_shift - 32),
      0
    );
  }
}

struct XmssSignature {
  uint wots_hashes[WOTS_CHAIN_COUNT][HASH_WORDS];
  uint xmss_merkle_path[XMSS_HEIGHT][HASH_WORDS];
};

struct ForsMerkleProof {
  uint preimage[HASH_WORDS];
  uint merkle_path[FORS_TREE_HEIGHT][HASH_WORDS];
};

#define ADRS_TYPE_WOTS_HASH 0
#define ADRS_TYPE_WOTS_PK 1
#define ADRS_TYPE_TREE 2
#define ADRS_TYPE_FORS_TREE 3
#define ADRS_TYPE_FORS_ROOTS 4
#define ADRS_TYPE_WOTS_PRF 5
#define ADRS_TYPE_FORS_PRF 6


#define define_schedule_1hash_midwords(hash, hash_address, schedule) { \
  schedule[5] = (hash_address << 16) | (hash[0] >> 16); \
  for (uint i = 1; i < HASH_WORDS; i++) { \
    schedule[5 + i] = (hash[i - 1] << 16) | (hash[i] >> 16); \
  } \
  schedule[5 + HASH_WORDS] = (hash[HASH_WORDS - 1] << 16) | 0x8000; \
  /* Padding */ \
  for (uint i = 5 + HASH_WORDS + 1; i < 15; i++) { \
    schedule[i] = 0; \
  } \
}

// SHA256 message length in bits.
// 8 * (
//   64             [pk_seed and padding]
//   22             [compressed adrs]
//   HASH_WORDS * 4 [hash]
// )
#define define_schedule_1hash(layer_address, adrs_type, keypair_address, chain_address, hash_address, tree_address, hash, schedule) { \
  schedule[0] = (layer_address << 24)   | (tree_address.hi >> 8); \
  schedule[1] = (tree_address.hi << 24) | (tree_address.lo >> 8); \
  schedule[2] = (tree_address.lo << 24) | (adrs_type << 16) | (keypair_address >> 16); \
  schedule[3] = (keypair_address << 16) | (chain_address >> 16); \
  schedule[4] = (chain_address << 16)   | (hash_address >> 16); \
  define_schedule_1hash_midwords(hash, hash_address, schedule) \
  schedule[15] = 8 * (64 + 22 + 4 * HASH_WORDS); \
}

void define_schedule_2hash(
  uint layer_address,
  uint adrs_type,
  uint keypair_address,
  uint node_height,
  uint node_index,
  uint64 tree_address,
  const in uint left_child[HASH_WORDS],
  const in uint right_child[HASH_WORDS],
  out uint schedule[64]
) {
  schedule[0] = (layer_address << 24) | (tree_address.hi >> 8);
  schedule[1] = (tree_address.hi << 24) | (tree_address.lo >> 8);
  schedule[2] = (tree_address.lo << 24) | (adrs_type << 16) | (keypair_address >> 16);
  schedule[3] = (keypair_address << 16) | (node_height >> 16);
  schedule[4] = (node_height << 16) | (node_index >> 16);
  schedule[5] = (node_index << 16)  | (left_child[0] >> 16);

  for (uint i = 0; i < HASH_WORDS - 1; i++) {
    schedule[6 + i] = (left_child[i] << 16) |
                      (left_child[i + 1] >> 16);
  }
  schedule[6 + HASH_WORDS - 1] = (left_child[HASH_WORDS - 1] << 16) | (right_child[0] >> 16);

  // For 192-bit and 256-bit parameter sets, we must invoke the compression function twice.
  if (HASH_WORDS > 4) {
    // TODO: sha512
  }
  for (uint i = 0; i < HASH_WORDS - 1; i++) {
    schedule[6 + HASH_WORDS + i] = (right_child[i] << 16) | (right_child[i + 1] >> 16);
  }
  schedule[6 + 2 * HASH_WORDS - 1] = (right_child[HASH_WORDS - 1] << 16) | 0x8000;

  // Padding
  for (uint i = 6 + 2 * HASH_WORDS; i < 15; i++) {
    schedule[i] = 0;
  }

  // msg_bit_len
  schedule[15] = 8 * (64 + 22 + 2 * HASH_WORDS * 4);
}

// Convert an N-byte hash to a base-W message to be signed by XMSS.
void convert_to_base_w(const in uint hash[HASH_WORDS], out uint message[WOTS_CHAIN_COUNT]) {
  for (uint i = 0; i < HASH_WORDS; i++) {
    #if WOTS_CHAIN_LEN == 256
      uint offset = i * 4;
      for (uint j = 0; j < 4; j++) {
        message[offset + j] = (hash[i] >> (24 - j*8)) & 0xFF;
      }
    #elif WOTS_CHAIN_LEN == 16
      uint offset = i * 8;
      for (uint j = 0; j < 8; j++) {
        message[offset + j] = (hash[i] >> (28 - j*4)) & 0xF;
      }
    #endif
  }

  // message is now initialized up to WOTS_CHAIN_COUNT1.
  // time to append the checksum.
  uint checksum = 0;
  for (uint i = 0; i < WOTS_CHAIN_COUNT1; i++) {
    checksum += WOTS_CHAIN_LEN - 1 - message[i];
  }
  for (uint i = 0; i < WOTS_CHAIN_COUNT2; i++) {
    message[WOTS_CHAIN_COUNT - 1 - i] = checksum & (WOTS_CHAIN_LEN - 1);
    checksum >>= WOTS_LOG_W;
  }
}

#define WOTS_TIPS_WORDS (WOTS_CHAIN_COUNT * HASH_WORDS)
#define WOTS_TIPS_LAST_BLOCK_WORDS ((WOTS_TIPS_WORDS - 10) % 16)

#define compute_xmss_leaf(\
  layer_address, \
  tree_address, \
  keypair_address, \
  sha256_state, \
  tips, \
  xmss_leaf \
) { \
  uint s[8] = sha256_state; \
  uint schedule[64]; \
  schedule[0] = (layer_address << 24)   | (tree_address.hi >> 8); \
  schedule[1] = (tree_address.hi << 24) | (tree_address.lo >> 8); \
  schedule[2] = (tree_address.lo << 24) | (ADRS_TYPE_WOTS_PK << 16) | (keypair_address >> 16); \
  schedule[3] = (keypair_address << 16); \
  schedule[4] = 0; /* chain_address and hash_address are left empty. */ \
  schedule[5] = tips[0] >> 16; \
 \
  /* Compute the first block. */ \
  for (uint i = 0; i < 10; i++) { \
    schedule[6 + i] = (tips[i] << 16) | \
                      (tips[i + 1] >> 16); \
  } \
  sha256_rounds_all(s, schedule); \
 \
  /* Compute the intermediate blocks. */ \
  for (uint q = 0; q < (WOTS_TIPS_WORDS - 10) / 16; q++) { \
    uint q16 = q * 16; \
    for (uint i = 0; i < 16; i++) { \
      schedule[i] = \
        (tips[10 + q16 + i] << 16) | \
        (tips[11 + q16 + i] >> 16); \
    } \
    sha256_rounds_all(s, schedule); \
  } \
 \
  /* Fill out the last block */ \
  for (uint i = 0; i < WOTS_TIPS_LAST_BLOCK_WORDS - 1; i++) { \
    schedule[i] = \
      (tips[WOTS_TIPS_WORDS - WOTS_TIPS_LAST_BLOCK_WORDS + i] << 16) | \
      (tips[WOTS_TIPS_WORDS - WOTS_TIPS_LAST_BLOCK_WORDS + i + 1] >> 16); \
  } \
  schedule[WOTS_TIPS_LAST_BLOCK_WORDS - 1] = (tips[WOTS_TIPS_WORDS - 1] << 16) | 0x8000; \
  for (uint i = WOTS_TIPS_LAST_BLOCK_WORDS; i < 15; i++) { \
    schedule[i] = 0; \
  } \
  schedule[15] = 8 * (64 + 22 + WOTS_CHAIN_COUNT * HASH_WORDS * 4); /* msg_bit_len */ \
 \
  /* Compute the last block. */ \
  sha256_rounds_all(s, schedule); \
 \
  /* Store the output in the correct region of the XMSS nodes output buffer */ \
  for (uint i = 0; i < HASH_WORDS; i++) { \
    xmss_leaf[i] = s[i]; \
  } \
}
