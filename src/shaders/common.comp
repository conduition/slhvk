// Work group size
layout(constant_id = 0) const uint WORK_GROUP_SIZE = 64;
layout(local_size_x_id = 0) in;

// Number of SHA256 state words to write to the output buffer.
//   HASH_WORDS = N / 4
layout(constant_id = 1) const uint HASH_WORDS = 4;

// SLH-DSA parameters
layout(constant_id = 2) const uint FORS_TREE_HEIGHT = 12;
layout(constant_id = 3) const uint FORS_TREE_COUNT = 14;
layout(constant_id = 4) const uint WOTS_LOG_W = 4;
layout(constant_id = 5) const uint WOTS_CHAIN_COUNT1 = 32;
layout(constant_id = 6) const uint WOTS_CHAIN_COUNT2 = 3;
layout(constant_id = 7) const uint XMSS_HEIGHT = 9;
layout(constant_id = 8) const uint HYPERTREE_LAYERS = 7;

const uint FORS_LEAVES_COUNT = 1 << FORS_TREE_HEIGHT;
const uint FORS_SIGNATURE_WORDS = HASH_WORDS * FORS_TREE_COUNT * (1 + FORS_TREE_HEIGHT);
const uint HYPERTREE_SIGNATURE_START_OFFSET = HASH_WORDS + FORS_SIGNATURE_WORDS;
const uint WOTS_CHAIN_COUNT = WOTS_CHAIN_COUNT1 + WOTS_CHAIN_COUNT2;
const uint WOTS_CHAIN_LEN = 1 << WOTS_LOG_W;
const uint XMSS_LEAVES = 1 << XMSS_HEIGHT;
const uint XMSS_SIGNATURE_WORDS = HASH_WORDS * (WOTS_CHAIN_COUNT + XMSS_HEIGHT);
const uint WOTS_CHAINS_PER_LAYER = XMSS_LEAVES * WOTS_CHAIN_COUNT;

const uint K[] = {
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

uint rotr(uint x, uint n) {
  return bitfieldInsert(x >> n, x, int(32 - n), int(n));
}

// By the boolean distributive law:
//   (x & y) ^ (x & z) = x & (y ^ z)
//
// Thus:
//   Maj(x, y, z) = (x & y) ^ (x & z) ^ (y & z)
//                = (x & (y ^ z)) ^ (y & z)
//
// This removes one XOR and one AND operation from the Maj function
uint maj(uint x, uint y, uint z) {
  return (x & (y ^ z)) ^ (y & z);
}

uint ch(uint e, uint f, uint g) {
  return (e & f) ^ ((~e) & g);
}

uint sum0(uint x) {
  return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
}

uint sum1(uint x) {
  return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
}

uint sigma0(uint x) {
  return rotr(x, 7) ^ rotr(x, 18) ^ (x >> 3);
}

uint sigma1(uint x) {
  return rotr(x, 17) ^ rotr(x, 19) ^ (x >> 10);
}

#define SHA256_ROUND(a, b, c, d, e, f, g, h, r, w) {\
  uint t1 = h + sum1(e) + ch(e, f, g) + K[r] + w; \
  uint t2 = sum0(a) + maj(a, b, c); \
  d = d + t1; \
  h = t1 + t2; \
}

#define populate_message_schedule(schedule, t) { \
  schedule[t] = \
    sigma1(schedule[t - 2]) + \
    schedule[t - 7] + \
    sigma0(schedule[t - 15]) + \
    schedule[t - 16]; \
}

#define sha256_rounds_5_thru_64(s, schedule, old_state) { \
  /*            a     b     c     d     e     f     g     h   round   w[round] */ \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  5,   schedule[5]) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  6,   schedule[6]) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  7,   schedule[7]) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  8,   schedule[8]) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  9,   schedule[9]) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  10,  schedule[10]) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  11,  schedule[11]) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  12,  schedule[12]) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  13,  schedule[13]) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  14,  schedule[14]) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  15,  schedule[15]) \
  populate_message_schedule(schedule, 16) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  16,  schedule[16]) \
  populate_message_schedule(schedule, 17) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  17,  schedule[17]) \
  populate_message_schedule(schedule, 18) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  18,  schedule[18]) \
  populate_message_schedule(schedule, 19) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  19,  schedule[19]) \
  populate_message_schedule(schedule, 20) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  20,  schedule[20]) \
  populate_message_schedule(schedule, 21) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  21,  schedule[21]) \
  populate_message_schedule(schedule, 22) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  22,  schedule[22]) \
  populate_message_schedule(schedule, 23) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  23,  schedule[23]) \
  populate_message_schedule(schedule, 24) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  24,  schedule[24]) \
  populate_message_schedule(schedule, 25) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  25,  schedule[25]) \
  populate_message_schedule(schedule, 26) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  26,  schedule[26]) \
  populate_message_schedule(schedule, 27) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  27,  schedule[27]) \
  populate_message_schedule(schedule, 28) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  28,  schedule[28]) \
  populate_message_schedule(schedule, 29) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  29,  schedule[29]) \
  populate_message_schedule(schedule, 30) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  30,  schedule[30]) \
  populate_message_schedule(schedule, 31) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  31,  schedule[31]) \
  populate_message_schedule(schedule, 32) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  32,  schedule[32]) \
  populate_message_schedule(schedule, 33) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  33,  schedule[33]) \
  populate_message_schedule(schedule, 34) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  34,  schedule[34]) \
  populate_message_schedule(schedule, 35) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  35,  schedule[35]) \
  populate_message_schedule(schedule, 36) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  36,  schedule[36]) \
  populate_message_schedule(schedule, 37) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  37,  schedule[37]) \
  populate_message_schedule(schedule, 38) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  38,  schedule[38]) \
  populate_message_schedule(schedule, 39) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  39,  schedule[39]) \
  populate_message_schedule(schedule, 40) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  40,  schedule[40]) \
  populate_message_schedule(schedule, 41) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  41,  schedule[41]) \
  populate_message_schedule(schedule, 42) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  42,  schedule[42]) \
  populate_message_schedule(schedule, 43) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  43,  schedule[43]) \
  populate_message_schedule(schedule, 44) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  44,  schedule[44]) \
  populate_message_schedule(schedule, 45) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  45,  schedule[45]) \
  populate_message_schedule(schedule, 46) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  46,  schedule[46]) \
  populate_message_schedule(schedule, 47) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  47,  schedule[47]) \
  populate_message_schedule(schedule, 48) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  48,  schedule[48]) \
  populate_message_schedule(schedule, 49) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  49,  schedule[49]) \
  populate_message_schedule(schedule, 50) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  50,  schedule[50]) \
  populate_message_schedule(schedule, 51) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  51,  schedule[51]) \
  populate_message_schedule(schedule, 52) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  52,  schedule[52]) \
  populate_message_schedule(schedule, 53) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  53,  schedule[53]) \
  populate_message_schedule(schedule, 54) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  54,  schedule[54]) \
  populate_message_schedule(schedule, 55) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  55,  schedule[55]) \
  populate_message_schedule(schedule, 56) \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  56,  schedule[56]) \
  populate_message_schedule(schedule, 57) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  57,  schedule[57]) \
  populate_message_schedule(schedule, 58) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  58,  schedule[58]) \
  populate_message_schedule(schedule, 59) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  59,  schedule[59]) \
  populate_message_schedule(schedule, 60) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  60,  schedule[60]) \
  populate_message_schedule(schedule, 61) \
  SHA256_ROUND(s[3], s[4], s[5], s[6], s[7], s[0], s[1], s[2],  61,  schedule[61]) \
  populate_message_schedule(schedule, 62) \
  SHA256_ROUND(s[2], s[3], s[4], s[5], s[6], s[7], s[0], s[1],  62,  schedule[62]) \
  populate_message_schedule(schedule, 63) \
  SHA256_ROUND(s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[0],  63,  schedule[63]) \
  for (int i = 0; i < 8; i++) { \
    s[i] += old_state[i]; \
  } \
}

#define sha256_rounds_0_thru_5(s, schedule) {\
  /*            a     b     c     d     e     f     g     h   round   w[round] */ \
  SHA256_ROUND(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],  0,   schedule[0]) \
  SHA256_ROUND(s[7], s[0], s[1], s[2], s[3], s[4], s[5], s[6],  1,   schedule[1]) \
  SHA256_ROUND(s[6], s[7], s[0], s[1], s[2], s[3], s[4], s[5],  2,   schedule[2]) \
  SHA256_ROUND(s[5], s[6], s[7], s[0], s[1], s[2], s[3], s[4],  3,   schedule[3]) \
  SHA256_ROUND(s[4], s[5], s[6], s[7], s[0], s[1], s[2], s[3],  4,   schedule[4]) \
}

#define sha256_rounds_all(s, schedule) { \
  const uint old_state[8] = s; \
  sha256_rounds_0_thru_5(s, schedule) \
  sha256_rounds_5_thru_64(s, schedule, old_state) \
}

uint flip_endianness(uint v) {
  return (
    bitfieldExtract(v, 0, 8) << 24 |
    bitfieldExtract(v, 8, 8) << 16 |
    bitfieldExtract(v, 16, 8) << 8 |
    bitfieldExtract(v, 24, 8)
  );
}

struct uint64 {
  uint lo;
  uint hi;
};

uint64 shifted_tree_address(uint64 tree_address, uint xmss_height, uint layer_address) {
  uint tree_shift = xmss_height * layer_address; // never more than 63
  if (tree_shift == 0) {
    return uint64(tree_address.lo, tree_address.hi);
  } else if (tree_shift < 32) {
    return uint64(
      (tree_address.hi << (32 - tree_shift)) | (tree_address.lo >> tree_shift),
      tree_address.hi >> tree_shift
    );
  } else {
    return uint64(
      tree_address.hi >> (tree_shift - 32),
      0
    );
  }
}

#define ADRS_TYPE_WOTS_HASH 0
#define ADRS_TYPE_WOTS_PK 1
#define ADRS_TYPE_TREE 2
#define ADRS_TYPE_FORS_TREE 3
#define ADRS_TYPE_FORS_ROOTS 4
#define ADRS_TYPE_WOTS_PRF 5
#define ADRS_TYPE_FORS_PRF 6


#define define_schedule_1hash_midwords(hash, hash_address, schedule) { \
  schedule[5] = (hash_address << 16) | (hash[0] >> 16); \
  for (uint i = 1; i < HASH_WORDS; i++) { \
    schedule[5 + i] = (hash[i - 1] << 16) | (hash[i] >> 16); \
  } \
  schedule[5 + HASH_WORDS] = (hash[HASH_WORDS - 1] << 16) | 0x8000; \
  /* Padding */ \
  for (uint i = 5 + HASH_WORDS + 1; i < 15; i++) { \
    schedule[i] = 0; \
  } \
}

void define_schedule_1hash(
  uint layer_address,
  uint adrs_type,
  uint keypair_address,
  uint chain_address,
  uint hash_address,
  uint64 tree_address,
  const in uint hash[HASH_WORDS],
  out uint schedule[64]
) {
  schedule[0] = (layer_address << 24)   | (tree_address.hi >> 8);
  schedule[1] = (tree_address.hi << 24) | (tree_address.lo >> 8);
  schedule[2] = (tree_address.lo << 24) | (adrs_type << 16) | (keypair_address >> 16);
  schedule[3] = (keypair_address << 16) | (chain_address >> 16);
  schedule[4] = (chain_address << 16)   | (hash_address >> 16);

  define_schedule_1hash_midwords(hash, hash_address, schedule)

  // SHA256 message length in bits.
  // 8 * (
  //   64             [pk_seed and padding]
  //   22             [compressed adrs]
  //   HASH_WORDS * 4 [hash]
  // )
  schedule[15] = 8 * (64 + 22 + 4 * HASH_WORDS);
}

// Common inputs available to all shaders.
layout(binding = 0) buffer inputs {
  // The SHA256 state after absorbing the `pk_seed` and padding.
  uint sha256_state[8];

  // Secret seed from the private key.
  uint sk_seed[HASH_WORDS];

  // adrs[1:4]
  uint64 tree_address;

  // the index of the WOTS keypair to be used for signing the message at hypertree layer zero.
  uint signing_keypair_address;
};
