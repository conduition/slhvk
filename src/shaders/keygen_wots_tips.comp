#version 430
#extension GL_GOOGLE_include_directive : enable
#include "keygen_common.comp"

uint THREAD_COUNT = keys_count * XMSS_LEAVES * WOTS_CHAIN_COUNT;

void main() {
  uint thread_id = gl_GlobalInvocationID.x;
  if (thread_id >= THREAD_COUNT) return;

  uint key_index = thread_id / WOTS_CHAINS_PER_LAYER;
  uint layer_address = HYPERTREE_LAYERS - 1; // always the root XMSS tree layer
  uint keypair_address = (thread_id % WOTS_CHAINS_PER_LAYER) / WOTS_CHAIN_COUNT;
  uint chain_address = thread_id % WOTS_CHAIN_COUNT;

  uint sk_seed_offset = key_index * HASH_WORDS;

  uint schedule[64];
  schedule[0] = (layer_address << 24);
  schedule[1] = 0;
  schedule[2] = (ADRS_TYPE_WOTS_PRF << 16) | (keypair_address >> 16);
  schedule[3] = (keypair_address << 16) | (chain_address >> 16);
  schedule[4] = (chain_address << 16);
  schedule[5] = (sk_seeds[sk_seed_offset] >> 16);
  for (uint i = 1; i < HASH_WORDS; i++) {
    schedule[5 + i] = (sk_seeds[sk_seed_offset + i - 1] << 16) | (sk_seeds[sk_seed_offset + i] >> 16);
  }
  schedule[5 + HASH_WORDS] = (sk_seeds[sk_seed_offset + HASH_WORDS - 1] << 16) | 0x8000;

  // Padding
  for (uint i = 5 + HASH_WORDS + 1; i < 15; i++) {
    schedule[i] = 0;
  }

  // SHA256 message length in bits.
  // 8 * (
  //   64             [pk_seed and padding]
  //   22             [compressed adrs]
  //   HASH_WORDS * 4 [hash]
  // )
  schedule[15] = 8 * (64 + 22 + 4 * HASH_WORDS);

  uint sha_offset = key_index * 8;
  uint s[8] = {
    sha256_states[sha_offset + 0], sha256_states[sha_offset + 1],
    sha256_states[sha_offset + 2], sha256_states[sha_offset + 3],
    sha256_states[sha_offset + 4], sha256_states[sha_offset + 5],
    sha256_states[sha_offset + 6], sha256_states[sha_offset + 7]
  };
  uint old_state[8] = s;

  // Invoke the PRF to generate the initial preimage of the WOTS hash chain.
  sha256_rounds_all(s, schedule);

  // Sets adrs type byte to WOTS_HASH = 0
  schedule[2] &= 0xFF00FFFF;

  // Precompute the first five rounds, as they are the same for every chain iteration.
  uint fifth_round_state[8] = old_state;
  sha256_rounds_0_thru_5(fifth_round_state, schedule);

  // Run the WOTS hash iteration function until we get to the chain tip.
  for (uint hash_address = 0; hash_address < WOTS_CHAIN_LEN - 1; hash_address++) {
    // fill in the schedule with the WOTS_PRF output (i == 0), or the WOTS_HASH
    // output from the prior iteration (i > 0).
    define_schedule_1hash_midwords(s, hash_address, schedule)

    // Run a new hash invocation using the precomputed 5th-round state
    s = fifth_round_state;
    sha256_rounds_5_thru_64(s, schedule, old_state);
  }

  uint offset = thread_id * HASH_WORDS;
  for (uint i = 0; i < HASH_WORDS; i++) {
    hash_chain_states[offset + i] = s[i];
  }
}
