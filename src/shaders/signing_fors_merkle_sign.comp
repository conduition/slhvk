#version 430
#extension GL_GOOGLE_include_directive : enable
#include "signing_common.comp"

// A set of A-bit indices into the K FORS trees
layout(binding = 1) buffer forsmsg {
  uint fors_message[FORS_TREE_COUNT];
};

// This buffer will be filled with FORS leaf nodes
layout(binding = 2) buffer forsnode {
  uint fors_node_states[FORS_TREE_COUNT][FORS_LEAVES_COUNT][HASH_WORDS];
};

// The FORS signature.
layout(binding = 3) buffer forssig {
  ForsMerkleProof fors_signature[FORS_TREE_COUNT];
};

// Merges two FORS child node hashes at positions `lnode_pos` and `rnode_pos`
// into a parent node hash at height `node_height` and index `node_index`.
// The output is written to `fors_node_states[fors_tree][lnode_pos]`.
void fors_node_merge(
  uint fors_tree,
  uint lnode_pos,
  uint rnode_pos,
  uint node_height,
  uint node_index
) {
  uint schedule[64];
  define_schedule_2hash(
    0, /* layer_address */
    ADRS_TYPE_FORS_TREE,
    signing_keypair_address,
    node_height,
    node_index,
    tree_address,
    fors_node_states[fors_tree][lnode_pos],
    fors_node_states[fors_tree][rnode_pos],
    schedule
  );

  uint s[8] = {
    sha256_state[0], sha256_state[1], sha256_state[2], sha256_state[3], // a b c d
    sha256_state[4], sha256_state[5], sha256_state[6], sha256_state[7]  // e f g h
  };
  sha256_rounds_all(s, schedule);

  // Write the compressed output to the left node position.
  for (uint i = 0; i < HASH_WORDS; i++) {
    fors_node_states[fors_tree][lnode_pos][i] = s[i];
  }
}

void main() {
  uint local_id = gl_LocalInvocationID.x;
  uint fors_tree = gl_WorkGroupID.x;

  // First find and write the height=0 merkle hash: the FORS node
  // at leaf index (fors_message[tree] ^ 1)
  if (local_id == 0) {
    uint first_hash_offset = fors_message[fors_tree] ^ 1;
    for (uint i = 0; i < HASH_WORDS; i++) {
      fors_signature[fors_tree].merkle_path[0][i] = flip_endianness(fors_node_states[fors_tree][first_hash_offset][i]);
    }
  }

  // For each layer in the FORS tree:
  for (uint node_height = 1; node_height <= FORS_TREE_HEIGHT; node_height++) {
    uint next_level_nodes_len = 1 << (FORS_TREE_HEIGHT - node_height);
    uint prev_layer_node_offset = (1 << (node_height - 1));
    uint global_node_index_offset = fors_tree * next_level_nodes_len;

    // Each thread may need to compute multiple nodes on this layer of the tree
    for (uint local_node_index = local_id; local_node_index < next_level_nodes_len; local_node_index += gl_WorkGroupSize.x) {
      uint left_child_index = local_node_index * 2;
      uint right_child_index = local_node_index * 2 + 1;

      uint lchild_offset = left_child_index * prev_layer_node_offset;
      uint rchild_offset = right_child_index * prev_layer_node_offset;

      fors_node_merge(
        fors_tree,
        lchild_offset,
        rchild_offset,
        node_height,
        global_node_index_offset + local_node_index
      );

      // A smidgeon of bit manipulation which determines if this node is one of the
      // nodes we need to write to the output FORS signature buffer.
      if (local_node_index == ((fors_message[fors_tree] >> node_height) ^ 1)) {
        for (uint i = 0; i < HASH_WORDS; i++) {
          fors_signature[fors_tree].merkle_path[node_height][i] = flip_endianness(fors_node_states[fors_tree][lchild_offset][i]);
        }
      }
    }

    // Synchronize the work group once each layer is computed. The next layer of nodes in each tree can only
    // safely be computed if all child nodes are correctly populated in the fors_node_states buffer.
    barrier();
  }

  // The FORS roots will be sent back to the host. Flip the bytes back to big-endian representation.
  if (local_id == 0) {
    for (uint i = 0; i < HASH_WORDS; i++) {
      fors_node_states[fors_tree][0][i] =
        flip_endianness(fors_node_states[fors_tree][0][i]);
    }
  }
}
