#version 430
#extension GL_GOOGLE_include_directive : enable
#include "common.comp"

struct SlhDsaSignatureVerifyRequest {
  uint pk_seed[HASH_WORDS];
  uint signing_keypair_address;
  uint64 tree_address;
  uint fors_indices[FORS_TREE_COUNT];
  ForsMerkleProof fors_merkle_proofs[FORS_TREE_COUNT];
  XmssSignature xmss_signatures[HYPERTREE_LAYERS];
};

layout(push_constant) uniform pc {
  uint signatures_len;
};

layout(binding = 0) buffer sig {
  SlhDsaSignatureVerifyRequest signatures[];
};

layout(binding = 1) buffer res {
  uint verify_results[][HASH_WORDS];
};

void flip_hash_endianness(
  const in uint hash[HASH_WORDS],
  out uint flipped[HASH_WORDS]
) {
  for (uint i = 0; i < HASH_WORDS; i++) {
    flipped[i] = flip_endianness(hash[i]);
  }
}

void compute_fors_root(
  uint thread_id,
  const in uint pk_seed_midstate[8],
  uint fors_tree_index,
  out uint fors_root[HASH_WORDS]
) {
  uint fors_node[HASH_WORDS];
  flip_hash_endianness(signatures[thread_id].fors_merkle_proofs[fors_tree_index].preimage, fors_node);

  uint64 tree_address = signatures[thread_id].tree_address;
  uint signing_keypair_address = signatures[thread_id].signing_keypair_address;
  uint fors_node_index_in_tree = signatures[thread_id].fors_indices[fors_tree_index];
  uint fors_node_index_global  = fors_tree_index * FORS_LEAVES_COUNT + fors_node_index_in_tree;

  uint schedule[64];
  define_schedule_1hash(
    0, /* layer_address */
    ADRS_TYPE_FORS_TREE,
    signing_keypair_address,
    0, /* tree_height */
    fors_node_index_global,
    signatures[thread_id].tree_address,
    fors_node,
    schedule
  );
  uint sha_state[8] = pk_seed_midstate;
  sha256_rounds_all(sha_state, schedule);

  for (uint i = 0; i < HASH_WORDS; i++) {
    fors_node[i] = sha_state[i];
  }

  for (uint node_height = 1; node_height <= FORS_TREE_HEIGHT; node_height++) {
    uint peer_node[HASH_WORDS];
    flip_hash_endianness(
      signatures[thread_id].fors_merkle_proofs[fors_tree_index].merkle_path[node_height - 1],
      peer_node
    );

    // Handle left/right side nodes in the tree
    if (((fors_node_index_in_tree >> (node_height - 1)) & 1) == 1) {
      uint tmp[HASH_WORDS] = fors_node;
      fors_node = peer_node;
      peer_node = tmp;
    }

    uint node_index = fors_node_index_global >> node_height;
    define_schedule_2hash(
      0, /* layer_address */
      ADRS_TYPE_FORS_TREE,
      signing_keypair_address,
      node_height,
      node_index,
      tree_address,
      fors_node,
      peer_node,
      schedule
    );
    sha_state = pk_seed_midstate;
    sha256_rounds_all(sha_state, schedule);
    for (uint i = 0; i < HASH_WORDS; i++) {
      fors_node[i] = sha_state[i];
    }
  }

  fors_root = fors_node;
}

#define FORS_ROOTS_WORDS (FORS_TREE_COUNT * HASH_WORDS)

void compute_fors_pubkey(
  uint64 tree_address,
  uint signing_keypair_address,
  const in uint pk_seed_midstate[8],
  const in uint fors_roots[FORS_ROOTS_WORDS],
  out uint fors_pubkey[HASH_WORDS]
) {

  uint offset_words_queue[FORS_ROOTS_WORDS + 1];
  offset_words_queue[0] = fors_roots[0] >> 16;
  for (uint i = 1; i < FORS_ROOTS_WORDS; i++) {
    offset_words_queue[i] = (fors_roots[i - 1] << 16) | (fors_roots[i] >> 16);
  }
  offset_words_queue[FORS_ROOTS_WORDS] = (fors_roots[FORS_ROOTS_WORDS - 1] << 16) | 0x8000;

  uint schedule[64];

  schedule[0] = (tree_address.hi >> 8);
  schedule[1] = (tree_address.hi << 24) | (tree_address.lo >> 8);
  schedule[2] = (tree_address.lo << 24) | (ADRS_TYPE_FORS_ROOTS << 16) | (signing_keypair_address >> 16);
  schedule[3] = (signing_keypair_address << 16);
  schedule[4] = 0;

  // Fill and process the first block
  uint ctr = 0;
  for (uint i = 0; i < 11; i++) {
    schedule[5 + i] = offset_words_queue[ctr++];
  }
  uint sha_state[8] = pk_seed_midstate;
  sha256_rounds_all(sha_state, schedule);

  // Fill and compute intermediate blocks
  for (uint q = 0; q < (FORS_ROOTS_WORDS - 10) / 16; q++) {
    uint q16 = q * 16;
    for (uint i = 0; i < 16; i++) {
      schedule[i] = offset_words_queue[ctr++];
    }
    sha256_rounds_all(sha_state, schedule);
  }

  // Fill and compute the last block
  uint k;
  for (k = 0; ctr < FORS_ROOTS_WORDS + 1; k++) {
    schedule[k] = offset_words_queue[ctr++];
  }
  for (; k < 15; k++) {
    schedule[k] = 0;
  }
  schedule[15] = 8 * (64 + 22 + FORS_ROOTS_WORDS * 4); // msg_bit_len
  sha256_rounds_all(sha_state, schedule);

  for (uint i = 0; i < HASH_WORDS; i++) {
    fors_pubkey[i] = sha_state[i];
  }
}

void xmss_compute_root(
  uint layer_address,
  uint64 tree_address,
  uint keypair_address,
  const in uint pk_seed_midstate[8],
  const in uint wots_message[WOTS_CHAIN_COUNT],
  const in XmssSignature xmss_sig,
  out uint xmss_root[HASH_WORDS]
) {
  uint schedule[64];

  // Begin WOTS tip computation
  uint wots_tip_hashes[WOTS_TIPS_WORDS];
  for (uint chain_address = 0; chain_address < WOTS_CHAIN_COUNT; chain_address++) {
    schedule[0] = (layer_address << 24)   | (tree_address.hi >> 8);
    schedule[1] = (tree_address.hi << 24) | (tree_address.lo >> 8);
    schedule[2] = (tree_address.lo << 24) | (ADRS_TYPE_WOTS_HASH << 16) | (keypair_address >> 16);
    schedule[3] = (keypair_address << 16) | (chain_address >> 16);
    schedule[4] = (chain_address << 16);

    uint fifth_round_state[8] = pk_seed_midstate;
    sha256_rounds_0_thru_5(fifth_round_state, schedule);

    // SHA256 message length in bits.
    // 8 * (
    //   64             [pk_seed and padding]
    //   22             [compressed adrs]
    //   HASH_WORDS * 4 [hash]
    // )
    schedule[15] = 8 * (64 + 22 + 4 * HASH_WORDS);

    uint tip_state[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    for (uint i = 0; i < HASH_WORDS; i++) {
      tip_state[i] = flip_endianness(xmss_sig.wots_hashes[chain_address][i]);
    }
    for (uint hash_address = wots_message[chain_address]; hash_address < WOTS_CHAIN_LEN - 1; hash_address++) {
      define_schedule_1hash_midwords(tip_state, hash_address, schedule)
      tip_state = fifth_round_state;
      sha256_rounds_5_thru_64(tip_state, schedule, pk_seed_midstate);
    }

    uint offset = chain_address * HASH_WORDS;
    for (uint i = 0; i < HASH_WORDS; i++) {
      wots_tip_hashes[offset + i] = tip_state[i];
    }
  }

  // Compute XMSS leaf node from the WOTS chain hash tips
  uint xmss_node[HASH_WORDS];
  compute_xmss_leaf(layer_address, tree_address, keypair_address, pk_seed_midstate, wots_tip_hashes, xmss_node);

  // begin XMSS merkle root computation
  uint xmss_node_index = keypair_address;
  uint peer_node[HASH_WORDS];
  uint sha_state[8];
  for (uint node_height = 1; node_height <= XMSS_HEIGHT; node_height++) {
    if ((xmss_node_index & 1) == 1) {
      peer_node = xmss_node;
      flip_hash_endianness(xmss_sig.xmss_merkle_path[node_height - 1], xmss_node);
    } else {
      flip_hash_endianness(xmss_sig.xmss_merkle_path[node_height - 1], peer_node);
    }
    xmss_node_index >>= 1;
    define_schedule_2hash(
      layer_address,
      ADRS_TYPE_TREE,
      0, /* keypair_address */
      node_height,
      xmss_node_index,
      tree_address,
      xmss_node, /* left child */
      peer_node, /* right child */
      schedule
    );
    sha_state = pk_seed_midstate;
    sha256_rounds_all(sha_state, schedule);
    for (uint i = 0; i < HASH_WORDS; i++) {
      xmss_node[i] = sha_state[i];
    }
  }

  for (uint i = 0; i < HASH_WORDS; i++) {
    xmss_root[i] = xmss_node[i];
  }
}

void main() {
  uint thread_id = gl_GlobalInvocationID.x;
  if (thread_id >= signatures_len) return;

  uint pk_seed_midstate[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
  };
  uint schedule[64];

  // Hash the PK seed block to generate the cached SHA256 midstate
  for (uint i = 0; i < HASH_WORDS; i++)
    schedule[i] = flip_endianness(signatures[thread_id].pk_seed[i]);
  for (uint i = HASH_WORDS; i < 64; i++)
    schedule[i] = 0;
  sha256_rounds_all(pk_seed_midstate, schedule);

  uint64 tree_address = signatures[thread_id].tree_address;
  uint signing_keypair_address = signatures[thread_id].signing_keypair_address;

  uint fors_roots[FORS_ROOTS_WORDS];
  uint fors_root[HASH_WORDS];
  for (uint i = 0; i < FORS_TREE_COUNT; i++) {
    compute_fors_root(
      thread_id,
      pk_seed_midstate,
      i, /* fors_tree_index */
      fors_root
    );
    uint i4 = i * HASH_WORDS;
    for (uint j = 0; j < HASH_WORDS; j++) {
      fors_roots[i4 + j] = fors_root[j];
    }
  }

  uint fors_pubkey[HASH_WORDS];
  compute_fors_pubkey(
    tree_address,
    signing_keypair_address,
    pk_seed_midstate,
    fors_roots,
    fors_pubkey
  );

  // Convert the FORS pubkey to a base-W message for XMSS verification;
  uint wots_message[WOTS_CHAIN_COUNT];
  convert_to_base_w(fors_pubkey, wots_message);

  uint64 tree_address_shifted = tree_address;
  uint keypair_address = signing_keypair_address;
  uint xmss_root[HASH_WORDS];

  for (uint layer_address = 0; layer_address < HYPERTREE_LAYERS; layer_address++) {
    xmss_compute_root(
      layer_address,
      tree_address_shifted,
      keypair_address,
      pk_seed_midstate,
      wots_message,
      signatures[thread_id].xmss_signatures[layer_address],
      xmss_root
    );

    // prep for next iteration
    convert_to_base_w(xmss_root, wots_message);

    keypair_address = tree_address_shifted.lo & (XMSS_LEAVES - 1);
    tree_address_shifted.lo = (tree_address_shifted.hi << (32 - XMSS_HEIGHT)) | (tree_address_shifted.lo >> XMSS_HEIGHT);
    tree_address_shifted.hi >>= XMSS_HEIGHT;
  }

  // xmss_root now stores the hypertree root hash. Write it to output in big-endian format.
  flip_hash_endianness(xmss_root, verify_results[thread_id]);
}
