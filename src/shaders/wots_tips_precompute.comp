#version 430
#extension GL_GOOGLE_include_directive : enable
#include "signing_common.comp"

/*****************************
  WOTS tips precompute shader
******************************

TODO

**************************/

const uint THREAD_COUNT = HYPERTREE_LAYERS * XMSS_LEAVES * WOTS_CHAIN_COUNT;

// The WOTS hash chain states. For all WOTS keypairs these will be filled with
// hash chains iterated to their tips.
layout(binding = 1) buffer chainstates {
  uint hash_chain_states[];
};

void main() {
  uint thread_id = gl_GlobalInvocationID.x;
  if (thread_id >= THREAD_COUNT) return;

  uint layer_address = thread_id / WOTS_CHAINS_PER_LAYER;
  uint keypair_address = (thread_id % WOTS_CHAINS_PER_LAYER) / WOTS_CHAIN_COUNT;
  uint chain_address = thread_id % WOTS_CHAIN_COUNT;

  uint64 tree_address_shifted = shifted_tree_address(tree_address, XMSS_HEIGHT, layer_address);

  uint schedule[64];
  define_schedule_1hash(
    layer_address,
    ADRS_TYPE_WOTS_PRF,
    keypair_address,
    chain_address,
    0, /* hash_address */
    tree_address_shifted,
    sk_seed,
    schedule
  );

  uint s[8] = {
    sha256_state[0], sha256_state[1], sha256_state[2], sha256_state[3], // a b c d
    sha256_state[4], sha256_state[5], sha256_state[6], sha256_state[7]  // e f g h
  };
  uint old_state[8] = s;

  // Invoke the PRF to generate the initial preimage of the WOTS hash chain.
  sha256_rounds_all(s, schedule);

  // Sets adrs type byte to WOTS_HASH = 0
  schedule[2] &= 0xFF00FFFF;

  // Precompute the first five rounds, as they are the same for every chain iteration.
  uint fifth_round_state[8] = old_state;
  sha256_rounds_0_thru_5(fifth_round_state, schedule);

  // Run the WOTS hash iteration function until we get to the chain tip.
  for (uint hash_address = 0; hash_address < WOTS_CHAIN_LEN - 1; hash_address++) {
    // fill in the schedule with the WOTS_PRF output (i == 0), or the WOTS_HASH
    // output from the prior iteration (i > 0).
    define_schedule_1hash_midwords(s, hash_address, schedule)

    // Run a new hash invocation using the precomputed 5th-round state
    s = fifth_round_state;
    sha256_rounds_5_thru_64(s, schedule, old_state);
  }

  uint offset = thread_id * HASH_WORDS;
  for (uint i = 0; i < HASH_WORDS; i++) {
    hash_chain_states[offset + i] = s[i];
  }
}
