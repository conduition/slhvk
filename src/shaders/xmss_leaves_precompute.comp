#version 430
#extension GL_GOOGLE_include_directive : enable
#include "common.comp"

const uint THREAD_COUNT = HYPERTREE_LAYERS * XMSS_LEAVES;
const uint WOTS_TIPS_WORDS = WOTS_CHAIN_COUNT * HASH_WORDS;
const uint LAST_BLOCK_WORDS = (WOTS_TIPS_WORDS - 10) % 16;

// The WOTS hash chain states. For all WOTS keypairs these will be filled with
// hash chains iterated to their tips.
layout(binding = 1) buffer chainstates {
  uint hash_chain_states[];
};

// The compressed WOTS public keys hash output states.
layout(binding = 2) buffer xmssnodes {
  uint xmss_node_states[];
};

void main() {
  uint thread_id = gl_GlobalInvocationID.x;
  if (thread_id >= THREAD_COUNT) return;

  uint layer_address = thread_id / XMSS_LEAVES;
  uint keypair_address = thread_id % XMSS_LEAVES;
  uint64 tree_address_shifted = shifted_tree_address(tree_address, XMSS_HEIGHT, layer_address);

  // Identify where this thread's WOTS hash chain tips begin in the chainstates buffer.
  uint tip_offset = thread_id * (WOTS_CHAIN_COUNT * HASH_WORDS);

  uint s[8] = {
    sha256_state[0], sha256_state[1], sha256_state[2], sha256_state[3], // a b c d
    sha256_state[4], sha256_state[5], sha256_state[6], sha256_state[7]  // e f g h
  };

  uint schedule[64];
  schedule[0] = (layer_address << 24)           | (tree_address_shifted.hi >> 8);
  schedule[1] = (tree_address_shifted.hi << 24) | (tree_address_shifted.lo >> 8);
  schedule[2] = (tree_address_shifted.lo << 24) | (ADRS_TYPE_WOTS_PK << 16) | (keypair_address >> 16);
  schedule[3] = (keypair_address << 16);
  schedule[4] = 0; // chain_address and hash_address are left empty.
  schedule[5] = hash_chain_states[tip_offset] >> 16;

  // Compute the first block.
  for (uint i = 0; i < 10; i++) {
    schedule[6 + i] = (hash_chain_states[tip_offset + i] << 16) |
                      (hash_chain_states[tip_offset + i + 1] >> 16);
  }
  sha256_rounds_all(s, schedule);


  // Compute the intermediate blocks.
  for (uint q = 0; q < (WOTS_TIPS_WORDS - 10) / 16; q++) {
    uint q16 = q * 16;
    for (uint i = 0; i < 16; i++) {
      schedule[i] =
        (hash_chain_states[tip_offset + 10 + q16 + i] << 16) |
        (hash_chain_states[tip_offset + 11 + q16 + i] >> 16);
    }
    sha256_rounds_all(s, schedule);
  }


  // Fill out the last block
  for (uint i = 0; i < LAST_BLOCK_WORDS - 1; i++) {
    schedule[i] =
      (hash_chain_states[tip_offset + WOTS_TIPS_WORDS - LAST_BLOCK_WORDS + i] << 16) |
      (hash_chain_states[tip_offset + WOTS_TIPS_WORDS - LAST_BLOCK_WORDS + i + 1] >> 16);
  }
  schedule[LAST_BLOCK_WORDS - 1] = (hash_chain_states[tip_offset + WOTS_TIPS_WORDS - 1] << 16) | 0x8000;
  for (uint i = LAST_BLOCK_WORDS; i < 15; i++) {
    schedule[i] = 0;
  }
  schedule[15] = 8 * (64 + 22 + WOTS_CHAIN_COUNT * HASH_WORDS * 4); // msg_bit_len

  // Compute the last block.
  sha256_rounds_all(s, schedule);

  // Store the output in the correct region of the pubkeys output buffer
  uint offset = thread_id * HASH_WORDS;
  for (uint i = 0; i < HASH_WORDS; i++) {
    xmss_node_states[offset + i] = s[i];
  }
}
