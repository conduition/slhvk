#version 430
#extension GL_GOOGLE_include_directive : enable
#include "signing_common.comp"

// The working buffer for XMSS node computations.
// Prefilled with WOTS public keys.
layout(binding = 1) buffer xmssnodes {
  uint xmss_node_states[HYPERTREE_LAYERS][XMSS_LEAVES][HASH_WORDS];
};

// The hypertree signature (a chain of XMSS signatures)
layout(binding = 2) buffer htsig {
  XmssSignature hypertree_signature[HYPERTREE_LAYERS];
};

// XMSS root hashes, converted into checksummed base-W messages (for WOTS signing).
layout(binding = 3) buffer rootmsg {
  uint xmss_root_messages[HYPERTREE_LAYERS][WOTS_CHAIN_COUNT];
};

// Merges two XMSS child node hashes at positions `lnode_pos` and `rnode_pos`
// into a parent node hash at height `node_height` and index `node_index`.
// The output is written to `xmss_node_states[layer_address][lnode_pos]`.
void xmss_node_merge(
  uint64 tree_address,
  uint layer_address,
  uint lnode_pos,
  uint rnode_pos,
  uint node_height,
  uint node_index
) {
  uint schedule[64];
  define_schedule_2hash(
    layer_address,
    ADRS_TYPE_TREE,
    0, /* keypair_address */
    node_height,
    node_index,
    tree_address,
    xmss_node_states[layer_address][lnode_pos],
    xmss_node_states[layer_address][rnode_pos],
    schedule
  );

  uint s[8] = {
    sha256_state[0], sha256_state[1], sha256_state[2], sha256_state[3], // a b c d
    sha256_state[4], sha256_state[5], sha256_state[6], sha256_state[7]  // e f g h
  };
  sha256_rounds_all(s, schedule);

  // Write the compressed output to the left node position.
  for (uint i = 0; i < HASH_WORDS; i++) {
    xmss_node_states[layer_address][lnode_pos][i] = s[i];
  }
}

void main() {
  // uint thread_id = gl_GlobalInvocationID.x;
  uint local_id = gl_LocalInvocationID.x;

  // One work group per layer of the hypertree.
  uint layer_address = gl_WorkGroupID.x;
  uint64 tree_address_shifted = shifted_tree_address(tree_address, XMSS_HEIGHT, layer_address);

  uint our_layer_signing_keypair_address = layer_address == 0
    ? signing_keypair_address
    : (shifted_tree_address(tree_address, XMSS_HEIGHT, layer_address - 1).lo & (XMSS_LEAVES - 1));

  // First find and write the height=0 merkle hash: the WOTS pubkey
  // at XMSS leaf index (signing_keypair_address ^ 1)
  if (local_id == 0) {
    uint first_hash_offset = our_layer_signing_keypair_address ^ 1;
    for (uint i = 0; i < HASH_WORDS; i++) {
      hypertree_signature[layer_address].xmss_merkle_path[0][i] = flip_endianness(xmss_node_states[layer_address][first_hash_offset][i]);
    }
  }

  // For each layer in the XMSS tree:
  for (uint node_height = 1; node_height <= XMSS_HEIGHT; node_height++) {
    const uint next_level_nodes_len = 1 << (XMSS_HEIGHT - node_height);

    uint prev_layer_node_offset = (1 << (node_height - 1));

    // Each thread may need to compute multiple nodes on this layer of the tree
    for (uint node_index = local_id; node_index < next_level_nodes_len; node_index += gl_WorkGroupSize.x) {
      uint left_child_index = node_index * 2;
      uint right_child_index = node_index * 2 + 1;

      uint lchild_offset = left_child_index * prev_layer_node_offset;
      uint rchild_offset = right_child_index * prev_layer_node_offset;

      xmss_node_merge(tree_address_shifted, layer_address, lchild_offset, rchild_offset, node_height, node_index);

      // A smidgeon of bit manipulation which determines if this node is one of the
      // nodes we need to write to the output XMSS signature buffer.
      if (node_index == ((our_layer_signing_keypair_address >> node_height) ^ 1)) {
        for (uint i = 0; i < HASH_WORDS; i++) {
          hypertree_signature[layer_address].xmss_merkle_path[node_height][i] = flip_endianness(xmss_node_states[layer_address][lchild_offset][i]);
        }
      }
    }

    // Synchronize the work group once each layer is computed. The next layer of nodes in each tree can only
    // safely be computed if all child nodes are correctly populated in the xmss_node_states buffer.
    barrier();
  }

  // Convert the XMSS root node to a base-W message, so it can be signed by the next XMSS
  // tree layer up (in the WOTS sign shader).
  if (local_id == 0 && layer_address < HYPERTREE_LAYERS - 1) {
    uint root_node[HASH_WORDS] = xmss_node_states[layer_address][0];
    uint message[WOTS_CHAIN_COUNT];
    convert_to_base_w(root_node, message);
    xmss_root_messages[layer_address + 1] = message;
  }
}
